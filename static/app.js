const chat = document.getElementById("chat");
const form = document.getElementById("composer");
const inpTicker = document.getElementById("ticker");
const selType = document.getElementById("assetType");
const chkSearch = document.getElementById("useSearch");
const inpQuestion = document.getElementById("question");
const chkYouTube = document.getElementById("useYouTube");

let appConfig = { features: { youtube: true }, youtube_requires_plan: false, plan: "free" };

function addMsg(role, html) {
  const wrap = document.createElement("div");
  wrap.className = `msg ${role}`;
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  bubble.innerHTML = html;
  wrap.appendChild(bubble);
  chat.appendChild(wrap);
  wrap.scrollIntoView({ behavior: "smooth", block: "end" });
}

function asBullets(items) {
  if (!items || !items.length) return "<em class='muted'>—</em>";
  return "<ul>" + items.map(x => {
    if (typeof x === "string") return `<li>${x}</li>`;
    const d = x.driver || x.risk || JSON.stringify(x);
    const why = x.why_it_matters ? ` — <span class='muted'>${x.why_it_matters}</span>` : "";
    const src = (x.source_ids && x.source_ids.length) ? ` <span class='small muted'>(sources: ${x.source_ids.join(", ")})</span>` : "";
    return `<li><b>${d}</b>${why}${src}</li>`;
  }).join("") + "</ul>";
}

function renderSources(sources) {
  if (!sources || !sources.length) return "<div class='muted small'>No sources attached.</div>";
  return `<table>
    <thead><tr><th>ID</th><th>Title</th><th>Published</th><th>Link</th></tr></thead>
    <tbody>${sources.map(s => `
      <tr>
        <td>${s.id}</td>
        <td>${s.title || ""}</td>
        <td>${s.published || ""}</td>
        <td><a href="${s.url}" target="_blank" rel="noopener">Open</a></td>
      </tr>`).join("")}
    </tbody>
  </table>`;
}

function renderTimeline(items) {
  if (!items || !items.length) return "<em class='muted'>—</em>";
  return `<table>
    <thead><tr><th>Driver</th><th>Timeframe</th><th>Expected Window</th><th>Likelihood</th><th>Confidence</th><th>Rationale</th><th>Signals</th><th>Sources</th></tr></thead>
    <tbody>
      ${items.map(i => `
        <tr>
          <td>${i.driver}</td>
          <td>${i.timeframe}</td>
          <td>${i.expected_window || ""}</td>
          <td>${(i.likelihood != null) ? (Math.round(i.likelihood*100)+"%") : ""}</td>
          <td>${i.confidence || ""}</td>
          <td>${i.rationale || ""}</td>
          <td>${(i.leading_indicators || []).join(", ")}</td>
          <td>${(i.source_ids || []).join(", ")}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>`;
}

function renderReport(r) {
  const head = `<div class='section-title'>${r.ticker} • ${r.entity_name || ""} <span class='muted small'>(${(r.asset_type || "").toUpperCase()})</span></div>
                <div class='muted small'>As of ${r.as_of || "now"} UTC</div>`;
  const summary = `<p>${r.summary || r.raw_text || ""}</p>`;

  const drivers = r.drivers || {};
  const near = drivers.near_term || {};
  const med  = drivers.medium_term || {};
  const long = drivers.long_term || {};

  const block = `
    ${head}
    <div class='section-title'>Near-term (0–3 months)</div>
    <b>Positives</b>${asBullets(near.positives)}
    <b>Negatives</b>${asBullets(near.negatives)}

    <div class='section-title'>Medium-term (3–12 months)</div>
    <b>Positives</b>${asBullets(med.positives)}
    <b>Negatives</b>${asBullets(med.negatives)}

    <div class='section-title'>Long-term (1–3+ years)</div>
    <b>Positives</b>${asBullets(long.positives)}
    <b>Negatives</b>${asBullets(long.negatives)}

    <div class='section-title'>Timeline assessment</div>
    ${renderTimeline(r.timeline_assessment)}

    <div class='section-title'>Risks & mitigants</div>
    ${asBullets(r.risks_and_mitigants)}

    <div class='section-title'>Sources</div>
    ${renderSources(r.sources_index)}

    <div class='muted small'>${r.disclaimer || "For education only. Not investment advice."}</div>
    <div class='muted small'>Generated by ${r._meta?.model || "model"} in ${r._meta?.timing_ms || "—"} ms.</div>
  `;
  addMsg("bot", summary + block);
}

form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const ticker = (inpTicker.value || "").trim().toUpperCase();
  if (!ticker) return;
  const assetType = selType.value || "auto";
  const useSearch = chkSearch.checked;
  const question = inpQuestion.value || "";

  addMsg("user", `<b>${ticker}</b> <span class='muted small'>(${assetType}, search: ${useSearch ? "on" : "off"})</span><br>${question || ""}`);
  const spinnerId = `spin-${Date.now()}`;
  addMsg("bot", `<span class="spinner" id="${spinnerId}"></span> <span class='muted'>Thinking...</span>`);

  try {
    const res = await fetch("/api/research", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ ticker, asset_type: assetType, use_search: useSearch, question })
    });

    const text = await res.text();
    let data = null;
    try { data = JSON.parse(text); } catch { /* leave as text */ }

    // Remove spinner bubble
    const spinEl = document.getElementById(spinnerId);
    if (spinEl) spinEl.parentElement.parentElement.remove();

    if (!res.ok) {
      const detail = (data && (data.detail || data.error || data.message)) || text || "Unknown error";
      addMsg("bot", `<b>API error ${res.status}</b><br><span class='muted small'>${detail}</span>`);
      return;
    }

    renderReport(data);
    if (chkYouTube.checked) {
      triggerYouTube(
        data.ticker,
        data.entity_name || data.ticker,
        data.asset_type || "auto",
        data.drivers || {}
      );
    }
  } catch (err) {
    const spinEl = document.getElementById(spinnerId);
    if (spinEl) spinEl.parentElement.parentElement.remove();
    addMsg("bot", `<b>Network error:</b> ${(err && err.message) || err}`);
  } finally {
    inpTicker.select();
  }

});

function renderYouTubeSection(y) {
  const head = `<div class='section-title'>YouTube sentiment (last ${y.lookback_days} days)</div>`;
  const agg = y.aggregate_sentiment && y.aggregate_sentiment.label
    ? `<div class='muted small'>Aggregate stance: <b>${y.aggregate_sentiment.label}</b>${(y.aggregate_sentiment.avg_score!=null?` (avg score ${y.aggregate_sentiment.avg_score.toFixed(2)})`:"")}</div>`
    : `<div class='muted small'>No transcripts analyzed.</div>`;

  const table = (!y.table_rows || !y.table_rows.length)
    ? "<div class='muted small'>No recent videos.</div>"
    : `<table>
         <thead>
           <tr>
             <th>Date</th><th>Time (UTC)</th><th>Title</th><th>Creator</th>
             <th>Transcript</th><th>Link</th>
           </tr>
         </thead>
         <tbody>
           ${y.table_rows.map(r => `
             <tr>
               <td>${r.date}</td>
               <td>${r.time}</td>
               <td>${r.title}</td>
               <td>${r.creator}</td>
               <td>${r.transcript_source || "—"}</td>
               <td><a href="${r.url}" target="_blank" rel="noopener">Watch</a></td>
             </tr>
           `).join("")}
         </tbody>
       </table>`;

  addMsg("bot", head + agg + table);
}


async function triggerYouTube(ticker, entityName, assetType, drivers) {
  const spinnerId = `spin-yt-${Date.now()}`;
  addMsg("bot", `<span class="spinner" id="${spinnerId}"></span> <span class='muted'>Scanning YouTube (last 7 days)...</span>`);
  try {
    const headers = { "Content-Type": "application/json" };
    if (appConfig?.plan) headers["X-Client-Plan"] = appConfig.plan;

    const res = await fetch("/api/youtube/sentiment", {
      method: "POST",
      headers,
      body: JSON.stringify({
        ticker,
        entity_name: entityName,
        asset_type: assetType,
        drivers,
        lookback_days: 7,
        max_videos: 5
      })
    });
    const text = await res.text();
    let data = null;
    try { data = JSON.parse(text); } catch { data = { error: text }; }
    const spinEl = document.getElementById(spinnerId);
    if (spinEl) spinEl.parentElement.parentElement.remove();
    if (!res.ok) {
      addMsg("bot", `<b>YouTube error ${res.status}</b><br><span class='muted small'>${data?.detail || data?.error || text}</span>`);
      return;
    }
    renderYouTubeSection(data);
  } catch (err) {
    const spinEl = document.getElementById(spinnerId);
    if (spinEl) spinEl.parentElement.parentElement.remove();
    addMsg("bot", `<b>YouTube fetch error:</b> ${err?.message || err}`);
  }
}

async function loadConfig() {
  try {
    const res = await fetch("/api/config");
    if (!res.ok) return;
    appConfig = await res.json();

    const ytEnabled = !(appConfig.features && appConfig.features.youtube === false);
    const requirePro = !!appConfig.youtube_requires_plan;
    const plan = (appConfig.plan || "free").toLowerCase();

    const wrap = document.getElementById("useYouTubeWrap");
    const pill = document.getElementById("useYouTubePill");
    const label = document.getElementById("useYouTubeLabel");

    if (!ytEnabled) {
      wrap.style.display = "none";
      return;
    }
    // Show Pro pill only if gated and user is not pro
    if (requirePro && plan !== "pro") {
      chkYouTube.disabled = true;
      chkYouTube.checked = false;
      pill.style.display = "inline-block";
      label.title = "Pro feature – upgrade to enable";
    } else {
      pill.style.display = "none";
    }
  } catch { /* ignore; default config already set */ }
}
loadConfig();
